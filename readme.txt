Modelling of Fractal Landscape:
A one dimensional array was used to represent the points on a n x n plane where n is 2^m + 1 where m is a
natural number. Initially, four random numbers are generated at the corners, then the algorithm takes in
averages from certain points based on whether it is doing a diamond step or a square step and add a random
number to it. In the diamond step, the base height is calculated by taking in average from the points that
are diagonal from a certain point with certain distance. In the square step, points that are horizontal
and vertical from a certain with certain distance. A random number is generated by setting an initial value
which serves as a variance and it will generate a random value with the range of negative value of the
variance to the variance. Each iteration, a diamond step is run, then the square step, then the distances
each step needs is halved (both are Initially n / 2) and the variance is halved. This is looped until
all arrays are filled.

Camera Motion:
The flight simulator style moving camera was implemented such that the 'w', 'a', 's', 'd' keys correspond to the
forward, left, backward and right direction respectively, and the camera can only be moved within a certain bounded box.
The bounding is achieved by reverting the camera to its previous position whenever it attempts to go out of bounds.
The camera also cannot clip into the mountains or the surface of the water. This was achieved using collision detection,
via Unity's CharacterController and MeshCollider components. Initially, only MeshCollider components were used, but it was 
limited to collision between convex meshes, which makes collisions inaccurate. Therefore, accurate collision detection is 
achieved by adding MeshCollider component to the terrain and water, and CharacterController component to the camera with the 
appropriate mesh, to keep it from looking inside the terrain or water. Finally, The mouse can freely control the pitch and 
yaw of the camera.

Surface Properties:
A mesh is generated for the terrain, and the colour of each polygon is determined by its height. To allow
for realistic lighting, the normal has to be calculated for each vertex which will determine how light
behaves when it hits the polygon. The lighting effects were achieved using the Phong illumination model.
Colours of the polygon varies according to the position of the orbiting sun and the height of each vertex.
The water section is rendered using a plane cutting across a terrain at a fixed height of zero.
The transparency of the plane has also been increased such that it mimics water more realistically.
Phong illumination was also applied to the water plane to ensure that it lights up and darkens consistently
with the landscape as the sun orbits. The sun is represented by an orbiting sphere in the program, and
illuminates the terrain according to its position in orbit.